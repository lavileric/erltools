/*************************************************************************/
/*                                                                       */
/*        speed.ch - Built by Eric Lavillonniere on Tandon 386 - 94      */
/*                                                                       */
/*************************************************************************/
/* This file is part of metagen                                             
   
   Metagen is a syntaxic analyser generator with backtrack.
   
   It runs on dos and unix. It generates c code. */
/* Copyright(C) 1989 Eric Lavillonniere */
/*
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; see the file COPYING. If not, write to 
   the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   
   */
language metalang;

#include "token.h"
#include "metalang.h"
#include "tablist.h"

extern int      houtput, coutput ;
static PTREE    listFuncNoStop = (PTREE)0 ; /* function with no stop : we can go
                                               through without taking anything */ 
static TabList  *listFuncToken = 0 ;        /* the list of tokens in functions */ 
static PTREE    rootTree = (PTREE)0 ;       /* the rootTree of the lex file
                                               analyzed*/ 

// PDESCRIPT_ELEM  FindStringDescript (char *, PTREE) ;
// PTREE           GetTokensFunctionName (PTREE) ;
// PTREE           GetTokensFunction (PTREE) ;
// void            FreeDescriptList () ;
// void            FreeArrayEntry () ;
// PTREE           FuncAccelerator (PTREE) ;
typedef struct array_entry {
    signed char       arrayEntry [MAX_TOKEN / 8];
    struct array_entry *next ;
}   ARRAY_ENTRY,    *PARRAY_ENTRY ;

static PARRAY_ENTRY listArrayEntry = (PARRAY_ENTRY)0 ;
static PARRAY_ENTRY listArrayEntryFree = (PARRAY_ENTRY)0 ;
static PARRAY_ENTRY arrayEntryCurrent = (PARRAY_ENTRY)0 ;
static signed char  arrayEntry [MAX_TOKEN / 8];
extern int          metaQuick ;
extern int          cplusGen ;
extern PTREE        theUsedGrammar ;
static PTREE        listLevel ; // the functions at each level

/*****************************************************/
/* Fill a list with all the stop token of the list   */
/*****************************************************/
// in this function _NO_STOP_ALL_FOUND indicates that we have seen a 
// contained function
// with a non stop . When we will expand the containing function
// the contained function 
// will generate a _NO_STOP_ALL but if there is the same number of
// _NO_STOP_ALL than _NO_STOP_ALL_FOUND then it means that the _NO_STOP_ALL
// have all been generated by the contained functions 
// for which we knew that were no stop function, so we correctly went
// on searching the containing function for stop tokens
//
// notice also that NO_STOP_ALL means that it is a function that must
// always be called, but also a function where we know all the beginning
// token we can find inside it. On the other side a _ALL_ means that
// this function might take any token.
int StopFind ( PTREE tree, PTREE list )
{
    PTREE   elem ;
    PTREE   statement, condition, statement1, statement2, tree1, tree2 ;
    
    if ( !tree ) 
        return 0 ;
    switch ( tree ) {
        case <MAKETREE,tree> : 
            
            /* skip tree name */
            nextl(tree);
        case <LIST> : 
            while ( tree ) {
                elem =  nextl(tree);
                if ( StopFind(elem, list) ) 
                    return 1 ;
            }
            return 0 ;
        case <REPLACETREE,tree> : 
            nextl(tree);
            nextl(tree);
            elem = nextl(tree);
            return StopFind(elem, list);
        case <ADDLIST,tree> : 
            nextl(tree);
            elem = nextl(tree);
            return StopFind(elem, list);
        case <NOT,tree> : 
            StopFind(tree, list);
            
            /* with a not take we can go on */
            return 0 ;
        case <COND,tree> : 
        case <EQUAL,<>,tree> : 
        case <BEGIN,tree> : return StopFind(tree, list);
        case <RETURN,tree> : return StopFind(tree, list);
        case <OR,tree1,tree2> : return StopFind(tree1, list) & StopFind(tree2, list);
        case <AND,tree1,tree2> : 
            if ( !StopFind(tree1, list) ) 
                return StopFind(tree2, list);
            return 1 ;
        case <CASE,tree> : 
            {
                int result = 1 ;
                while ( tree ) {
                    elem =  nextl(tree);
                    elem == <SWITCH,condition,statement>;
                    if ( !StopFind(condition, list) ) 
                        result &= StopFind(statement, list);
                }
                return result ;
            }
        case <BREAK> : return 1 ;
        case <TAKE,tree> : 
            if ( tree == <EXCLA,"NOTHING"> ) 
                list *= <STRING,"_ALL_">;
            else if ( tree == <IDENT> ) {
                if ( !ListFind(listFuncNoStop, tree) ) {
                    list *= copytree(tree);
                    return 1 ;
                } else {
                    list =  list * copytree(tree) * <STRING,"_NO_STOP_ALL_FOUND_">;
                    return 0 ;
                }
            } else {
                list *= copytree(tree);
                return 1 ;
            }
        case <SEE,tree> : 
            {
                if ( tree == <EXCLA,"NOTHING"> ) 
                    return 0 ;
                else 
                    list *= copytree(tree);
                return 1 ;
            }
        case <WITHOUT_CONTEXT,<>,statement> : 
        case <WITH_CONTEXT,<>,statement> : return StopFind(statement, list);
        case <REPEAT,statement,condition> : 
            if ( !StopFind(statement, list) ) {
                return StopFind(condition, list);
            } else 
                return 1 ;
        case <IF,condition,statement1,statement2> : 
            
            // if condition is like not (sthing) it blocks the else statement
            // and the following of the if so the stop is only dependant on
            // on the statement1
            while ( condition == <COND,condition> || condition == <NOT,<NOT,condition>> ) 
                ;
            if ( condition == <NOT,condition> ) {
                if ( StopFind(condition, list) ) 
                    return StopFind(statement1, list);
                else 
                    return StopFind(statement1, list) & StopFind(statement2, list);
            } else {
                if ( StopFind(condition, list) ) 
                    return StopFind(statement2, list);
                else 
                    return StopFind(statement1, list) & StopFind(statement2, list);
            }
        case <WHILE,condition,statement> : 
            while ( condition == <COND,condition> || condition == <NOT,<NOT,condition>> ) 
                ;
            if ( condition == <NOT,tree1> && StopFind(tree1, list) ) {
                StopFind(statement, list);
                return 1 ;
            } else if ( !StopFind(condition, list) ) 
                StopFind(statement, list);
            return 0 ;
        case <ASIT> : 
        case <SKIP> : 
        case <TAKEL> : 
        case <SEEL> : 
        case <STOREL> : 
        case <RESETL> : 
        case <FORGETL> : 
        case <RECOVERL> : 
        case <FORGET> : 
        case <RECOGNIZE_STRING> : 
            
            /* something too complex to do anything */
            list *= <STRING,"_ALL_">;
            
            // return 1 since it is of no use exploring further in the
            // the text of rule when we have found sthing that takes everything
            return 1 ;
        default : return 0 ;
    }
}

/*********************************************************/
/* FunctionContent : Get function content of function    */
/*********************************************************/
void    FunctionExpand (PTREE, TabList *, PTREE) ;

PTREE FunctionContent ( function, allFunction, stacked )
PTREE   function ; /* the function */ 
TabList *allFunction ;
PTREE   stacked ;  /* the function allready being scanned */ 
{
    PTREE   elem ;
    PTREE   retValue ;
    
    /* search for function */
    if ( (elem = (PPTREE)(*allFunction)[function]) ) {
        
        /* expand the function if not allready done */
        FunctionExpand(elem, allFunction, stacked);
        
        /* copy token list */
        nextl(elem); /* skip name */ 
        nextl(elem); /* skip array pointer */ 
        retValue =  copytree(elem);
    } else {
        
        // we didn't find the function so say it 
        char    message [MAXLENGTH];
        retValue =  <LIST,<STRING,"_ALL_">,()>;
        sprintf(message, "Could not find rule : %s \n", Value(function));
        _write(2, message, strlen(message));
    }
    
    /* suppress not expanded names  */
    {
        PTREE   list = retValue ;
        while ( list ) {
            if ( list == <,<IDENT>> ) {
                if ( list == retValue ) {
                    list == <,<>,list>;
                    retValue =  list ;
                } else {
                    PTREE   father = fathertree(list);
                    list == <,<>,list>;
                    father += <,<>,list>;
                }
            }
            nextl(list);
        }
    }
    return retValue ;
}

/*********************************************************/
/* FunctionExpand : expansion of a function              */
/*********************************************************/
void FunctionExpand ( function, allFunction, stacked )
PTREE   function ; /* the function to be expanded */ 
TabList *allFunction ;
PTREE   stacked ;  /* functions allready stacked */ 
{
    PTREE   elem ;
    PTREE   name ;
    PTREE   functionBase ;
    PTREE   functionElem ;      /* a pointer in the token of the function */ 
    int     recomputeFunction ; /* indicates if we must recompute function
                                   since it takes a function with no stop */ 
    
    /* get on token list */
debut : 
    functionElem = functionBase = function ;
    name =  nextl(functionElem);
    nextl(functionElem); /* skip array pointer */ 
    /*expand all */
    while ( functionElem ) {
        elem =  nextl(functionElem);
        
        /* if we have got a function not in the stack expand it */
        if ( elem == <IDENT> ) {
            PTREE   stackList ;
            if ( !strcmp(Value(elem), Value(functionBase)) ) {
                PTREE   father = fathertree(elem);
                
                /* suppress the element calling itself */
                father == <,<>,elem>;
                father =  fathertree(father);
                father += <,<>,elem>;
            } else {
                
                /* don't loop expanding a function, there is no
                   reason expanding a function allready in the stack list */
                if ( !ListFind(stacked, functionBase) ) {
                    PTREE   newContent ;
                    PTREE   father = fathertree(elem);  /* on list */ 
                    father     =  fathertree(father); /* on predecessor */ 
                    
                    /* compute expansion */
                    stackList  =  copytree(stacked);
                    stackList  *= copytree(name);
                    newContent =  FunctionContent(elem, allFunction, stackList);
                    
                    /* connect expansion */
                    father     += <,<>,newContent>;
                    
                    /* connect tail of function */
                    while ( father != <,<>,()> ) 
                        father == <,<>,father>;
                    father += <,<>,functionElem>;
                }
            }
        } else if ( !strcmp(value(elem), "_ALL_") ) {
            break ;
        }
    }
    functionElem      =  functionBase ;
    recomputeFunction =  0 ;
    nextl(functionElem);
    
    /* if we find "_ALL_" anywhere  put all everywhere */
    while ( functionElem ) {
        elem =  nextl(functionElem);
        if ( !strcmp(value(elem), "_ALL_") ) {
            functionBase      += <,<>,<,<>,<LIST,<STRING,"_ALL_">,()>>>;
            recomputeFunction =  0 ;
            break ;
        } else if ( !strcmp(value(elem), "_NO_STOP_ALL_") ) {
            
            /* one of the token we have kept is a function which
               can take no token, so we must recompute our function */
            recomputeFunction += 1 ;
        } else if ( !strcmp(value(elem), "_NO_STOP_ALL_FOUND_") ) {
            recomputeFunction -= 1 ;
        }
    }
    
    /* if we must recompute function do it */
    if ( recomputeFunction ) {
        if ( !ListFind(listFuncNoStop, function) ) {
            functionBase += <,<>,<,<>,GetTokensFunctionName(name)>>;
            goto debut ;
        }
    }
}

/*********************************************************/
/* FunctionSort : sort the tokens of a function          */
/*********************************************************/
void FunctionSort ( function )
PTREE   function ;
{
    
    PTREE   compare ; /* compare all the tokens to this one */ 
    PTREE   current ; /* the token being compared */ 
    
    nextl(function); /* the name */ 
    nextl(function); /* the array pointer */ 
    compare =  function ;
    
    /* compare all the elem to the first */
    while ( compare ) {
        char    *name = AllocString(value(compare));
        PTREE   compareElem = nextl(compare);
        
        /* NO_STOP_ALL ... must be used as couples we must not
           touch them */
        if ( !strcmp(name, "_NO_STOP_ALL_") || !strcmp(name, "_NO_STOP_ALL_FOUND_") ) 
            continue ;
        current =  compare ;
        while ( current ) {
            PTREE   currentElem = nextl(current);
            
            /* if the the two elem are the same destroy the second */
            if ( qcomparetree(compareElem, currentElem) ) {
                PTREE   father = fathertree(currentElem);
                father == <,<>,currentElem>;
                father =  fathertree(father);
                father += <,<>,currentElem>;
            } else if ( !strcmp(name, value(currentElem)) ) {
                char    Message [MAXLENGTH];
                sprintf(Message, "Two types of token for %s \n", name);
                _write(2, Message, strlen(Message));
            }
        }
        free(name);
    }
}

/*********************************************************/
/* TreeTokenAnalyze : treatment of whole tree            */
/*********************************************************/
int nbRule = 0 ;

/* get tokens of a function of a given name */
PTREE GetTokensFunctionName ( func )
PTREE   func ;
{
    PTREE   tree = rootTree ;
    PTREE   name ;
    
    foreach ((),tree,{
        if ( for_elem == <DEFINE,name> ) {
            if ( !strcmp(value(for_elem), value(func)) ) {
                return GetTokensFunction(for_elem);
            }
            goto for_continue ;
        } else if ( for_elem == <LEXDEFINE> ) {
            goto for_continue ;
        }
    })
    
    /* if we didn't find the function say that it's a no stop function */
    {
        PTREE   list = <LIST,<STRING,"_ALL_">,()>;
        listFuncNoStop *= copytree(name);
        return list ;
    }
}

/* get tokens of a function */
PTREE GetTokensFunction ( func )
PTREE   func ;
{
    PTREE   list = <LIST,(),()>;
    PTREE   name, pattern ;
    int     stop ;
    
    if ( func == <DEFINE,name,pattern> ) {
        
        /* analyze the function */
        stop =  StopFind(pattern, list);
        
        /* if we didn't find sthing in the function always get inside
           and indicates that we must not protect it */
        if ( !stop ) {
            list           *= <STRING,"_NO_STOP_ALL_">;
            listFuncNoStop *= copytree(name);
        }
        
        // suppress first void elem inserted
        nextl(list);
    }
    
    // suppress commentaries for example pos commentaries
    foreach ((),list,
        replacetree(for_elem, 0, (PTREE)0)
    )
    
    /* return the stop tokens of the function */
    return list ;
}

static int  nbArrayEntry = (int)0 ; // number of elems in listArrayEntry

void TreeTokenAnalyze ( const PTREE &tree )
{
    PTREE   name, list, listFunc, elem, function, newList ;
    TabList *ptTabList ; // pointer on table to speed up function access
    
    if ( listArrayEntry ) {
        FreeArrayEntry();
    }
    rootTree =  tree ;
    
    /* compute the tokens for each function */
    listFunc =  <LIST,(),()>;
    foreach ((),tree,{
        if ( for_elem == <DEFINE,name> ) {
            
            /* add the function and it's tokens to the general list */
            list     =  <LIST,copytree(name),<LIST,<LIST,(),()>,GetTokensFunction(for_elem)>>;
            listFunc *= list ;
            goto for_continue ;
        } else if ( for_elem == <LEXDEFINE> ) {
            goto for_continue ;
        }
    })
    
    // suppress first void cell
    nextl(listFunc);
    
    /* expand the list */
    list      =  listFunc ;
    ptTabList =  new TabList(listFunc);
    while ( list ) {
        elem =  nextl(list);
        FunctionExpand(elem, ptTabList, <LIST,<IDENT,"_ROOT_">,()>);
    }
    delete ptTabList ;
    
    /* sort every element */
    list =  listFunc ;
    while ( list ) {
        elem =  nextl(list);
        FunctionSort(elem);
    }
    
    // << EL 27/11/97
#   if 0
        listFuncNoStop =  ();
        rootTree       =  ();
#   endif
    
    /* compute the new listFuncToken */
    if ( !listFuncToken ) {
        listFuncToken =  new TabList(listFunc);
        listFuncToken->Sort();
        list =  listFunc ;
        while ( (elem = nextl(list)) ) {
            newList *= <IDENT,MakeString(Value(elem))>;
        }
        listLevel =  <LIST,newList,()>;
    } else {
        
        // update content of all function allready present
        // put every new function inside the list
        list =  listFunc ;
        while ( (elem = nextl(list)) ) {
            if ( !(*listFuncToken)[elem] ) {
                newList *= <IDENT,MakeString(Value(elem))>;
            }
            listFuncToken->InsertRemove(elem);
        }
        
        // update listLevel
        listLevel *= newList ;
    }
    
    // sort array
    listFuncToken->Sort();
    
    // make sure that listArrayEntry is computed along
    // listLevel order
    list =  listLevel ;
    while ( list ) {
        elem =  nextl(list);
        while ( (name = nextl(elem)) ) {
            function =  FuncAccelerator(name);
        }
    }
}

/*********************************************************/
/* FuncAccelerator  : Look if we have an accelerator for
                 func
   (PTREE) 0     : no accelerator
   (PTREE) -1    : function succeed in every case
   (PTREE) X     : there is an accelerator
          returns a list with :
                  nbArrayEntry : entry to look in
                  lexNumber    : number of lex function
                  lexName      : name of lex function to call
                                                  */
/*********************************************************/
void FreeArrayEntry ()
{
    PARRAY_ENTRY    pt = listArrayEntry ;
    
    while ( pt->next ) 
        pt =  pt->next ;
    pt->next           =  listArrayEntryFree ;
    listArrayEntryFree =  listArrayEntry ;
    arrayEntryCurrent  =  listArrayEntry = (PARRAY_ENTRY)0 ;
    nbArrayEntry       =  0 ;
}

PARRAY_ENTRY AllocArrayEntryUnit ()
{
    PARRAY_ENTRY    pt ;
    
    if ( listArrayEntryFree ) {
        pt                 =  listArrayEntryFree ;
        listArrayEntryFree =  listArrayEntryFree->next ;
    } else {
        pt =  (PARRAY_ENTRY)malloc(sizeof(ARRAY_ENTRY));
    }
    pt->next =  (PARRAY_ENTRY)0 ;
    if ( arrayEntryCurrent ) {
        arrayEntryCurrent->next =  pt ;
    } else 
        listArrayEntry =  pt ;
    arrayEntryCurrent =  pt ;
    return pt ;
}

PTREE FuncAccelerator ( funcName )
PTREE   funcName ; /* name of function we are looking for an accelerator */ 
{
    
    PTREE   funcElem ;     // an element of list 
                           // of functions
    PTREE   tokenElem ;    /* a token of the function */ 
    int     lexEntry = -1 ;
    PTREE   lexEntryFunc ; /* lex function parsing the tokens */ 
    
    if ( metaQuick ) 
        return (PTREE)0 ;
    
    /* search for the function */
    if ( (funcElem = (PPTREE)(*listFuncToken)[funcName]) ) {
        PTREE   ptArray ;
        PTREE   funcInit = funcElem ;
        nextl(funcElem); // skip name
        ptArray =  nextl(funcElem);
        
        /* if we have allready an array entry for the function get
           it now */
        if ( ptArray != <LIST,(),()> ) {
            
            /* we have an entry */
            return ptArray ;
        } else {
            
            /* otherwise compute the entry now */
            int nbNoStop = 0 ;
            int getAll = 0 ;
            
            /* initialize array entry */
            {
                int i ;
                for ( i = MAX_TOKEN / 8 ; i-- ;) 
                    arrayEntry [i] =  '\0';
            }
            
            /* first look if it is not a no stop function */
            {
                PTREE   tokenList = funcElem ;
                while ( (tokenElem = nextl(tokenList)) ) {
                    
                    /* if we get all stop now */
                    if ( tokenElem == <STRING,"_ALL_"> ) {
                        getAll =  1 ;
                        break ;
                    } else if ( tokenElem == <STRING,"_NO_STOP_ALL_"> ) {
                        nbNoStop += 1 ;
                        continue ;
                    } else if ( tokenElem == <STRING,"_NO_STOP_ALL_FOUND_"> ) {
                        nbNoStop -= 1 ;
                        continue ;
                    }
                }
            }
            
            // << EL 25/11/97
            // if function failed looked if failed directly or because of a called 
            // function
            if ( getAll || nbNoStop ) {
                PTREE   listToken ; // list of token for this function
                int     oldOutput = output ;
                bool    noStopAllFound = false ;
                listToken =  GetTokensFunctionName(funcName);
                while ( (tokenElem = nextl(listToken)) ) {
                    if ( tokenElem == <STRING,"_ALL_"> ) {
                        output =  2 ;
                        gotocol(1);
                        "Warning -> Rule may take all tokens" <NL>
                        output =  oldOutput ;
                        break ;
                    } else if ( tokenElem == <STRING,"_NO_STOP_ALL_FOUND_"> ) {
                        noStopAllFound =  true ;
                        continue ;
                    } else if ( !noStopAllFound && tokenElem == <STRING,"_NO_STOP_ALL_"> ) {
                        output =  2 ;
                        gotocol(1);
                        "Warning -> Rule must allways be looked at" <NL>
                        output =  oldOutput ;
                        break ;
                    }
                    noStopAllFound =  false ;
                }
            }
            
            /* compute the array entry for the function */
            if ( !getAll && !nbNoStop ) {
                PDESCRIPT_ELEM  pDescript = (PDESCRIPT_ELEM)0 ;
                PDESCRIPT_ELEM  ptDescriptOld = (PDESCRIPT_ELEM)0 ;
                int             nbToken ;
                while ( funcElem ) {
                    tokenElem =  nextl(funcElem);
                    
                    /* don't get into account _NO_STOP* they are well
                       balanced otherwise nbNoStop would not be 0 as
                       computed above */
                    if ( tokenElem == <STRING,"_NO_STOP_ALL_"> ) {
                        continue ;
                    } else if ( tokenElem == <STRING,"_NO_STOP_ALL_FOUND_"> ) {
                        continue ;
                    }
                    switch ( tokenElem ) {
                        case <TOKEN> : 
                            pDescript = FindStringDescript(AddKey(value(tokenElem)), tokenElem);
                            if ( cplusGen ) 
                                nbToken =  AddConst(AddKey(value(tokenElem)));
                            else 
                                nbToken =  AddConst(AddKey(value(tokenElem)));
                            break ;
                        case <STRING> : 
                        case <EXCLA> : 
                            pDescript = FindStringDescript(SymboName(value(tokenElem), 0), tokenElem);
                            nbToken   = AddConst(SymboName(value(tokenElem), 0));
                            break ;
                        default : 
                            pDescript = (PDESCRIPT_ELEM)0 ;
                            lexEntry  = -2 ;
                            nbToken   = 0 ;
                    }
                    if ( pDescript ) {
                        
                        /* look if it is the same lex entry as the other */
                        if ( lexEntry == -1 ) {
                            lexEntry      =  pDescript->offset ;
                            lexEntryFunc  =  pDescript->proc ;
                            ptDescriptOld =  pDescript ;
                        } else if ( lexEntry != pDescript->offset ) {
                            int             oldOutput = output ;
                            
                            // if there is a meta it's of no importance
                            PDESCRIPT_ELEM  ptDescriptMeta = FindStringDescript("META", (PTREE)0);
                            
                            // if the one which was put was a meta override it
                            if ( ptDescriptOld == ptDescriptMeta ) {
                                lexEntry      =  pDescript->offset ;
                                lexEntryFunc  =  pDescript->proc ;
                                ptDescriptOld =  pDescript ;
                            }
                            
                            // if current is meta dont take it into account
                            if ( pDescript != ptDescriptMeta ) {
                                
                                //    Flush();
                                output =  2 ;
                                gotocol(1);
                                "Warning -> Rule use lex entry : " WriteString(Value(lexEntryFunc)) " and " WriteString(Value(pDescript->proc)) <NL>
                                gotocol(1);
                                WriteString("    For entries ") WriteString(pDescript->name) WriteString(" And ") WriteString(ptDescriptOld->name) <NL>
                                output   =  oldOutput ;
                                lexEntry =  -1 ;
                                break ;
                            }
                        }
                        
                        /* set arrayEntry */
                        SET_ARRAY_VALUE(arrayEntry, nbToken);
                    } else {
                        lexEntry =  -2 ;
                        break ;
                    }
                }
            }
            
            /* if meta exists add it to the list of entry point*/
            if ( FindStringDescript("META", (PTREE)0) ) {
                int nbToken = AddConst("META");
                SET_ARRAY_VALUE(arrayEntry, nbToken);
            }
            if ( nbNoStop > 0 ) 
                lexEntry =  -3 ;
            
            /* if everything was ok create a new entry in description
               table */
            funcElem =  funcInit ;
            nextl(funcElem);
            if ( lexEntry >= 0 ) {
                PARRAY_ENTRY    pt = AllocArrayEntryUnit();
                memcpy(pt->arrayEntry, arrayEntry, MAX_TOKEN / 8);
                {
                    char    name [10];
                    sprintf(name, "%d", nbArrayEntry++);
                    funcElem += <,<LIST,<LIST,<NUMB,MakeString(name)>,()>,copytree(lexEntryFunc)>>;
                    sprintf(name, "%d", lexEntry);
                    funcElem += <,<,<,<>,MakeString(name)>>>;
                    funcElem == <,funcElem>;
                    return funcElem ;
                }
            } else {
                PARRAY_ENTRY    pt = AllocArrayEntryUnit();
                if ( lexEntry == -2 ) {
                    int oldOutput = output ;
                    
                    //                    Flush();
                    output =  2 ;
                    
                    // <NL>;
                    gotocol(1);
                    "Warning -> no lex entry for : ";
                    switch ( tokenElem ) {
                        case <TOKEN> : "#";
                        case <STRING> : 
                            "\"" WriteString(value(tokenElem)) "\"";
                            break ;
                        case <EXCLA> : 
                            "!" WriteString(value(tokenElem));
                            break ;
                    }
                    <NL>
                    output =  oldOutput ;
                }
                
                // here we must create an entry where we
                // always go
                /* initialize array entry with 1 everywhere 
                   since we must always go inside this function*/
                {
                    int i ;
                    for ( i = MAX_TOKEN / 8 ; i-- ;) 
                        arrayEntry [i] =  '\377';
                }
                memcpy(pt->arrayEntry, arrayEntry, MAX_TOKEN / 8);
                {
                    char    name [10];
                    sprintf(name, "%d", nbArrayEntry++);
                    funcElem += <,<LIST,<LIST,<NUMB,MakeString(name)>,()>,MakeString("0")>>;
                    sprintf(name, "%d", 0);
                    funcElem += <,<,<,<>,MakeString(name)>>>;
                    funcElem == <,funcElem>;
                }
                
                /* if ( lexEntry != -3) */
                {
                    int oldOutput = output ;
                    <NL>
                    output =  2 ;
                    gotocol(1);
                    "Warning ===> not optimized : " WriteString(value(funcName)) <NL,2>
                    output =  oldOutput ;
                }
                return funcElem ;
            }
        }
    }
    
    /* we didn't succeed while we didn't find the function */
    return (PTREE)0 ;
}

/*********************************************************/
/* ConvertToOctal : get octal string from an integer */
/*********************************************************/
static char stringConvert [4];

char *ConvertToOctal ( numb )
int numb ;
{
    int nb1, nb2, nb3 ;
    
    nb1                  =  numb >> 6 & 0x3 ;
    nb2                  =  numb >> 3 & 0x7 ;
    nb3                  =  numb & 0x7 ;
    *(stringConvert)     =  '0' + nb1 ;
    *(stringConvert + 1) =  '0' + nb2 ;
    *(stringConvert + 2) =  '0' + nb3 ;
    *(stringConvert + 3) =  '\0';
    return stringConvert ;
}

/*********************************************************/
/* DumpTokenArray : dump the array for the functions
   tokens    */
/*********************************************************/
extern int  numberConst ;

void DumpTokenArray ()
{
    PARRAY_ENTRY    ptArray = listArrayEntry ;
    char            name [20];
    int             ligne, col ;
    
    if ( metaQuick ) 
        return ;
    
    /* Dump meaning of array as a comment */
    "/* " <NL>
    for ( ligne = 0 ; ligne < nbArrayEntry ; ligne++ ) {
        PTREE   list = listFuncToken->List();
        sprintf(name, "%d", ligne);
        sprintf(name, "-- %d -- ", ligne);
        WriteString(name);
        sprintf(name, "%d", ligne);
        
        // dump lines which does not contain only 1
        while ( list ) {
            PTREE   elem = nextl(list);
            if ( !strcmp(Value(sontree(elem, 2)), name) ) {
                value(elem)
                elem == <,<>,<,<,<>,elem>>>;
                if ( strcmp(Value(elem), "0") ) {
                    <NL>
                        <T> {{
                                for ( col = 0 ; col < numberConst ; col++ ) {
                                    if ( GET_ARRAY_VALUE(ptArray->arrayEntry, col) ) 
                                        WriteString(NameConst(col)) 
                                    <NL>
                                }
                            }} <NL>
                } else {
                    <NL>
                        <T> "ALWAYS" <NL>
                }
                break ;
            }
        }
        ptArray =  ptArray->next ;
    }
    "*/" <NL,2>
    
    /* put definition of array in h file */
    output =  houtput ;
    
    // generates array
    sprintf(name, "%d", nbArrayEntry);
    if ( cplusGen ) {
            <T> "static ";
    } else {
        "extern ";
    }
    "signed char * ";
    if ( cplusGen ) 
        WriteString("_tokenArray") 
    else 
        WriteString(NameLang("_tokenArray")) 
    " [" WriteString(name) "];" <NL>
    
    // put definition of lex function array and nbFunc in 
    // h file
    if ( cplusGen ) {
            <T>
    }
    "static int (" WriteString(LanguageName(LO_CASE)) "::*(";
    if ( cplusGen ) {
        WriteString("_tokenFuncArray");
    } else 
        WriteString(NameLang("_tokenFuncArray")) 
    sprintf(name, "%d", nbArrayEntry);
    " [" WriteString(name) "])) ();" <NL>
    if ( cplusGen ) {
            <T>
    }
    "static int ";
    if ( cplusGen ) 
        WriteString("_tokenNbFuncArray") 
    else 
        WriteString(NameLang("_tokenNbFuncArray")) 
    sprintf(name, "%d", nbArrayEntry);
    " [" WriteString(name) "];" <NL,2>
    
    // put pointer of definition of lex function array and nbFunc in 
    // h file if not a derived grammar
    if ( theUsedGrammar == () ) {
            <T> "signed char **ptTokenArray;" <NL>
            <T> "int (" WriteString(LanguageName(LO_CASE)) "::** ptTokenFuncArray) ();" <NL>
            <T> "int *ptTokenNbFuncArray;" <NL,2>
    }
    
    /* then dump the array in c file */
    output  =  coutput ;
    ptArray =  listArrayEntry ;
    sprintf(name, "%d", nbArrayEntry);
    "signed char *";
    if ( cplusGen ) {
        WriteString(LanguageName(LO_CASE)) WriteString("::") WriteString("_tokenArray");
    } else {
        WriteString(NameLang("_tokenArray"));
    }
    " [" WriteString(name) "] = " "{" <NL>
        <T> {{
                for ( ligne = 0 ; ligne < nbArrayEntry ; ligne++ ) {
                    "(signed char *) \"";
                    for ( col = 0 ; col < (numberConst + 8) / 8 ; col++ ) {
                        sprintf(name, "\\%s", ConvertToOctal(ptArray->arrayEntry [col]));
                        WriteString(name);
                    }
                    "\"" <NL>
                    if ( ligne < nbArrayEntry - 1 ) 
                        "," 
                    ptArray =  ptArray->next ;
                }
            }}
    "};" <NL>
    sprintf(name, "%d", nbArrayEntry);
    "typedef int (" WriteString(LanguageName(LO_CASE)) "::*(";
    if ( cplusGen ) {
        WriteString("DEF_FUNC_TOKEN_ARRAY");
    } else {
        WriteString(NameLang("_tokenFuncArray"));
    }
    " [" WriteString(name) "]))() ;" <NL>
    "DEF_FUNC_TOKEN_ARRAY " WriteString(LanguageName(LO_CASE)) "::_tokenFuncArray = " "{" <NL>
        <T> {{
                for ( ligne = 0 ; ligne < nbArrayEntry ; ligne++ ) {
                    PTREE   list = listFuncToken->List();
                    if ( ligne != 0 ) {
                        "," <NL>
                    }
                    sprintf(name, "%d", ligne);
                    while ( list ) {
                        PTREE   elem = nextl(list);
                        if ( !strcmp(Value(sontree(elem, 2)), name) ) {
                            "/*" value(elem)
                            gotocol(38);
                            "*/";
                            elem == <,<>,<,<,<>,elem>>>;
                            gotocol(40);
                            if ( strcmp(Value(elem), "0") ) {
                                "(&";
                                if ( cplusGen ) {
                                    WriteString(LanguageName(LO_CASE)) WriteString("::") WriteString(Value(elem));
                                } else 
                                    WriteString(NameLang(Value(elem))) 
                                ")";
                                break ;
                            } else {
                                value(elem)
                            }
                            break ;
                        }
                    }
                }
            }} <NL>
    "};" <NL>
    sprintf(name, "%d", nbArrayEntry);
    "int ";
    if ( cplusGen ) {
        WriteString(LanguageName(LO_CASE)) WriteString("::") WriteString("_tokenNbFuncArray");
    } else {
        WriteString(NameLang("_tokenNbFuncArray"));
    }
    " [" WriteString(name) "] = " "{" <NL>
        <T> {{
                for ( ligne = 0 ; ligne < nbArrayEntry ; ligne++ ) {
                    PTREE   list = listFuncToken->List();
                    if ( ligne != 0 ) {
                        "," <NL>
                    }
                    sprintf(name, "%d", ligne);
                    while ( list ) {
                        PTREE   elem = nextl(list);
                        if ( !strcmp(Value(sontree(elem, 2)), name) ) {
                            "/*" value(elem)
                            gotocol(38);
                            "*/";
                            gotocol(40);
                            elem == <,<>,<,<,<,<>,elem>>>>;
                            WriteString(Value(elem));
                            break ;
                        }
                    }
                }
            }} <NL>
    "};" <NL>
}

/*********************************************************/
/* GetWithContext : get the with context                 */
/*********************************************************/
PTREE GetWithContext ( PTREE tree )
{
    PTREE   name, list ;
    PTREE   theList ;
    
    foreach ((),tree,{
        if ( for_elem == <WITH_CONTEXT,name> || for_elem == <WITHOUT_CONTEXT,name> ) {
            name =  copytree(name);
            
            // if name is not allready in list insert it
            if ( !ListFind(list, name) ) {
                list *= name ;
            }
        }
    })
    return list ;
}

//
//  ReleasePosComment : release the positionnal commentaries which
//                      are not used for output #line
//
void ReleasePosComment ( PTREE tree )
{
    PTREE   list, elem, son1, son2 ;
    
    // do nothing on null tree
    if ( tree == () ) 
        return ;
    
    // look on all trees skipping node where we
    // want to keep pos commentaries
    switch ( tree ) {
        case <DEFINE,elem,list> : 
        case <LEXDEFINE,elem,list> : 
        case <REPEAT,list> : 
        case <BEGIN,list> : 
        case <CASE,list> : 
            replacetree(elem, 0, (PTREE)0);
            while ( (elem = nextl(list)) ) {
                ReleasePosComment(elem);
            }
            break ;
        case <WHILE,elem,son1> : 
        case <WITHOUT_CONTEXT,elem,son1> : 
        case <WITH_CONTEXT,elem,son1> : 
        case <SWITCH,elem,son1> : 
        case <IF,elem,son1,son2> : 
            replacetree(elem, 0, (PTREE)0);
            ReleasePosComment(son1);
            ReleasePosComment(son2);
            break ;
        default : 
            forallsons (tree,{
                if ( for_elem != <DEFINE> && for_elem != <LEXDEFINE> ) 
                    replacetree(for_elem, 0, (PTREE)0);
                ReleasePosComment(for_elem);
            })
            break ;
    }
}


